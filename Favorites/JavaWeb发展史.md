## 一、原起

唉，说来惭愧，本来是想整理一下 SpringBoot 相关的知识，顺便结合书和网上的资料写一套完整的东西来作为以后复习、供大家借鉴，然后想先写一篇介绍SpringBoot的文章作为开篇，可是要介绍SpringBoot就得好好说说Spring，，好吧还是一点点来，先把Spring的东西好好整理一下吧。那么先来一篇介绍Spring版本和起源的文章吧，问题又来 了...为啥要用Spring啊？没有Spring之前用什么啊？（对于我这个刚开始接触没几年时间的程序猿，一开始接触的就是框架，也许这就是人们常说的生在好时代了吧 哇哈哈）好吧，抱着我的好奇心还是先看看整个Java Web的发展史（就联想到这里吧！在想可能要回去翻翻汇编的书了），看看都是怎么一点点的发展到现在这个地步的吧，上网找了好些类似的文章，做了对比，这里整理一下当做了解和以后的查阅，虽然好些没经历过，但也尽量准确的记录下~~~

## 二、JavaWeb发展历程

### 1. Servlet出现之前

servlet大多数人还是了解的，也还在使用，这里就从servlet说起吧。传说在上世纪90年代，因为nternet和浏览器的飞速发展，使得基于浏览器的B/S模式随之火爆发展起来。最初，用户使用浏览器向WEB服务器发送的请求都是请求静态的资源，比如html、css等。 但是可以想象：根据用户请求的不同动态的处理并返回资源是理所当然必须的要求，例如用户提交一些东西，服务器就能按提交的内容反馈用户不同的效果。所以人们应该非常迫切想要推出一项技术来实现动态的处理， java 为了应对上述需求，促进了servlet技术诞生。

### 2. Servlet出现（纯Servlet开发）

SUN公司刚刚推出JavaEE（Java企业版）时，推出了Servlet这个东西，命名就是Service+Applet，即服务小程序。Servlet可以说是Java技术中最早的Web解决方案，Servlet与普通Java类的编写非常类似。在Servlet中可以通过挨着行输出Html等语句来实现页面的样式和输出，数据的动态功能当然也就实现了。表现、逻辑、控制、业务全部混在Servlet类中。下面给出一个简单例子来直观感受一下。

```java
public void doGet(HttpServletRequest request,HttpServletResponse)
   throws IOException,ServletException
{
    response.setContentType("text/html;charset=gb2312");
    PrintWriter out = response.getWriter();
    out.println("<html>");
    out.println("<head><title>Hello World！</title></head>");
    out.println("<body>");
    out.println("<p>Hello World！</p>");
    out.println("</body></html>");
}
```

这样就动态的生成了一个内容为Hello World!的HTML页面在浏览器上显示。

一项技术的出现必然解决了一些现存的问题，但是我们知道servlet之后还有好些技术来替代在servlet中生成HTML页面的方式，那就说明servlet还存在痛点。从上面代码中我们可以看到servlet编程其实很繁琐：

servlet代码有大量冗余代码，out输出就得写上百遍；

开发servlet必须精通网页前端和美工，你得非常不直观的在Servlet中写前端代码，这使得实现各种页面效果和风格非常困难。

对于后端来说，所有的业务逻辑、页面跳转、央视表现全部混杂在同一个类中，并且一项业务一般只有一个Servlet类与其对应，实在是….太麻烦了。

所以为了解决这些问题（真庆幸晚生了好多年），sun公司借鉴 微软的asp,正式推出了JSP（servlet1.1）

### 3.JSP（纯JSP开发）

经过纯Servlet开发的噩梦之后，Sun公司又推出（或者说是倡导）了JSP技术，全称是Java Server Page，JSP中采用HTML语言直接生成界面，还可以在界面中使用<% %>脚本标识嵌入Java代码，揪其本质也是最终生成一个Servlet类来编译解析。如果要开发具有大量网页内容的网站，可以先使用网页编辑工具编写网页，然后在网页中嵌入处理代码即可。再来一个简单的例子：

```jsp
<html>

   <head><title>测试</title></head>

   <body>
     显示的内容是：<% String aa= “hello” ; out.println(aa); %>
    </body>
</html>
```

虽然JSP可以实现网站的快速开发，但依然存在缺点：网站的输入输出、处理、控制全部夹杂在一起，维护不方便，即使只需要修改该页面的一个简单按钮文本，或者一段静态的文本内容，也不得不打开混杂的动态脚本的页面源文件进行修改。当网站中需要进行大量的处理代码的时候，JSP文件将很难维护，并且代码也不容易共享。

前端开发人员需要看大量他看不懂的后端代码；

同样，servlet开发人员也在复杂的前端代码中找到其能写servlet代码的地方

因为JSP在编写网页方面具有优势，而编写处理代码存在很多问题，所以人们把JSP中的处理代码使用JavaBean来实现。于是出现了JSP+JavaBean的开发模式（有人叫做Model1开发模式，为什么这么叫，嗯~~不知道~~~）。

### 4. JSP+JavaBean（Model1）

这里就要首先弄清楚JavaBean到底是啥?JavaBean 是一种JAVA语言写成的可重用组件。为写成JavaBean，类必须是具体的和公共的，并且具有无参数的构造器。JavaBean 通过提供符合一致性设计模式的公共方法将内部域暴露成员属性，set和get方法获取（百度）。其实可以理解就是Java类，这里我理解为JavaBean的出现作为和数据库交互的类，Jsp页面里边中写部分Java代码用于转发等操作以及HTML页面的生成代码，而获取数据的方式以及部分业务逻辑则通过JavaBean来实现。整体结构

​                  

这种开发模式有一个简单的分层 JSP：表现层、控制层 JavaBean：模型层  利用我们现在熟悉的MVC模型的思想去看，虽然编写代码十分容易，但Jsp混淆了MVC模型中的视图层和控制层，高度耦合的结果是Jsp代码十分复杂，后期维护依旧困难。由原有的Model1开发模式转变成Model2开发模式，即Servlet+JSP+JavaBean。同时也使得在Web项目中将MVC设计模式实现。

### 5.Servlet+JSP+JavaBean（Model2）

Model1虽然在一定程度上解耦了，但JSP依旧即要负责页面控制，又要负责逻辑处理，职责不单一！此时Model2应运而生，使得各个部分各司其职，Model2是基于MVC模式的。Model2的开发模式是：Jsp+Servlet+JavaBean的模式，它和Model1不同的是，增加了Servlet。

在这种开发模式下，JSP页面中就可以不用任何的<%%>语句了，包括<%=%>全部用EL表达式来代替，列表的遍历和条件判断等（Java中的for循环和if语句）也可以通过JSTL来代替。 这样的话视图层相比较之前的开发模式来说要薄得多的多，JSP中不涉及任何的业务逻辑，前端人员修改样式也十分方便。这里可以理解为JSP为MVC设计模式中的V,即视图。

控制层通过Servlet来实现，获取前台传的参数、控制页面跳转，封装对象、向前台传输对象或者参数。并且可以由自己设计，设法用一个Servlet类实现该模块的所有功能的页面跳转。这里可以理解为Servlet为MVC设计模式中的C,即控制器。

但这里要说明的是Model2并不是一个完全标准的MVC设计模式，因为JavaBean还过于臃肿，并不能完全作为M层存在，所以将JavaBean再一次进行分割：业务逻辑、数据持久化。

### 6.三层架构与MVC设计模式
这里首先讨论一下三层架构和MVC的关系。我们大多数人总会把三层架构和MVC混为一谈，其实并非如此。三层架构是指软件系统的整体设计分层：业务逻辑层、数据持久化层和表现层。而MVC设计模式只体现在表现层中，即将表现层又分为模型、视图和控制器。所以在上面Model2模式下对JavaBean分割后形成了三层架构与MVC的全新的JavaWeb开发模式。

这里在分别介绍一下三层架构以及MVC设计模式：

三层架构：

表现层（Web层）：通俗说就是用户所能看到的直观的界面。其作用就是接收用户提交的请求数据，以及将程序对用户请求所产生的响应数据反馈给用户。目的就是为用户提供可交互的操作界面。所以，表现层就像已经搭好的积木。

业务逻辑层：简单讲就是“具体问题，具体分析”。它根据用户的不同请求而做出不同响应的处理。可以说是对数据层的一种整合方式。所以，就如同每个人会根据自己的喜好搭建不同的积木一样，业务逻辑层代表的就是搭积木的方式。

数据访问层（持久化）：它只是提供对数据库操作的多种途径。不同的数据就好比形状各异的积木，而数据访问层就好比取出或放回这些积木的动作。

MVC设计模式：

模型（Model）：封装的是数据源和所有基于对这些数据的操作。在一个组件中，Model往往表示组件的状态和操作状态的方法。

视图（View）：封装的是对数据源Model的一种显示。一个模型可以由多个视图，而一个视图理论上也可以与不同的模型关联起来。

控制器（Control）：封装的是外界作用于模型的操作。通常，这些操作会转发到模型上，并调用模型中相应的一个或者多个方法。一般Controller在Model和View之间起到了沟通的作用，处理用户在View上的输入，并转发给Model。这样Model和View两者之间可以做到松散耦合，甚至可以彼此不知道对方，而由Controller连接起这两个部分。

至此，页面的表现由jsp实现，转发控制由servlet实现，业务逻辑写在业务逻辑层，操作数据库部分写在持久化层，分工明确，各司其职。Model1、Model2、三层是在解耦的基础上一步步进化而来，通过解耦我们可以进行进一步的抽象，以应对现实需求的变动。这里要说的就是，从servlet一直到三层架构的转变，其实都是为了实现高内聚，低耦合。一步一步将各个功能分配到不同的地方实现。

ps:https://blog.csdn.net/weixin_39893958/article/details/84335159 这里整理了一些关于高内聚，低耦合的内容。

## 三、小结

前面也只是简单说来一下Javaweb发展历程中的一小部分，随着时间的推演，后面又出现企业级JavaBean EJB等大型框架，再到我们熟悉的Spring、SpringBoot。而Spring诞生之初，主要目的是用来替代更加重量级的企业级技术 尤其是EJB，相对于EJB来说Spring提供了更加轻量级和简单的编程模型。它增强了简单老式的Java对象POJO的功能，使其具备了之前只有EJB和其他企业级Java规范才有的功能。

EJB没用过，所以就Spring和EJB的比较以及Spring对于EJB的提升优点等不作过多解释，但从前面的种种发展历程来看，我们现在使用的Spring等都相对来说简单、方便了很多，框架的产生也对Javaweb开发影响极深，也是发展的必然趋势。简单了解了下Javaweb的发展趋势，下面在继续说说我们为什么会选择Spring，即Spring的优缺点。
————————————————

转载-原文链接：https://blog.csdn.net/weixin_39893958/article/details/84389384